<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Agent</title>
    <link href="/2023/10/07/Agent/"/>
    <url>/2023/10/07/Agent/</url>
    
    <content type="html"><![CDATA[<h1>Agent概念</h1><ul><li>基础： Transformer</li><li>特征： 大参数 1750B, 大数据</li><li>效果:<ul><li>涌现 20B以后出现的飞跃<ul><li>微软一篇论文称chatgpt只有20B量级参数</li></ul></li><li>AGI 通用人工智能</li></ul></li><li>LLM面向任务, 而LLM支持的Agent面向环境<ul><li>记忆 规划 工具使用 互动</li><li>互动包括与环境,Agent和人类</li></ul></li><li>场景:<ul><li>单Agent</li><li>多Agent: 合作, 辩论<ul><li>MIT google发现辩论可以提高LLM的推理能力与准确率</li></ul></li><li>人机互动</li><li>智能体社会<ul><li>Stanford的agent 小镇</li></ul></li></ul></li><li>GPT4 Trubo<ul><li>上下文 128k</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组实验_实现cache</title>
    <link href="/2023/10/07/csArch_lab/"/>
    <url>/2023/10/07/csArch_lab/</url>
    
    <content type="html"><![CDATA[<ul><li><p>m位的地址先后由t位标记, s位组索引和b为块偏移组成.</p></li><li><p>单级cache, 没有存储器的实现, 则如何处理不命中呢</p></li><li><p>wbwa在lru和lfu中, 不命中时分别有分配invalid块来写入 与 替换两种情况, 那么两种情况中对应的lru值与count block值分别如何变化.</p></li><li><p>被替换时dirty要变化，是否要在lru和lfu中加入参数表明是read还是write</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP day1</title>
    <link href="/2023/09/25/NLP_day1/"/>
    <url>/2023/09/25/NLP_day1/</url>
    
    <content type="html"><![CDATA[<ul><li>循环神经网络<ul><li>隐藏层中较全连接层多了个W(每个时间点的权重矩阵),每时刻的隐藏层由该时刻输入层和上一时刻的隐藏层共同决定.</li><li>RNN适合处理序列数据, 该时刻的输出同前一时刻的输入有关, 故对序列敏感.</li></ul></li><li>LSTM<ul><li>LSTM通过门控机制(包括input gate, forget gate, output gate)对memory cell进行选择, 分别决定.<ul><li>i</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自然语言处理 day1</title>
    <link href="/2022/09/19/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%861/"/>
    <url>/2022/09/19/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%861/</url>
    
    <content type="html"><![CDATA[<ul><li>语言是人为创造的承载信息的符号系统.<ul><li>符号是人为创造的, 没有天然意义.</li></ul></li><li>自然语言是结构化的一维序列.<ul><li>中文中最小语义单位是语素,可以是字或词</li><li>数学, 代码, 语音, DNA序列, 音乐(但是音乐具有二维性质,同时间会有很多条声轨), 蛋白质(但是蛋白质具有复杂的三维结构)</li></ul></li><li>分词-&gt;词性标注-&gt;识别专有名词-&gt;句法关系分析-&gt;语义分析(包括语义角色分析(施动者, 受动者)等).(传统做法)  深度学习常用端到端的处理,忽略这些中间环节(实际是模型完成的).</li><li>理解(NLU: L-&gt;R(representation))和生成(NLG: R-&gt;L)</li><li>有本体的等价物方便做逆向,但从现象到有限完备不靠谱<ul><li>从汉语到汉语语法结构到英语语法到英语;词性标注再或者从词到词(深度学习自己选择合适的层次).</li><li>在深度学习进行端到端的处理时,会从源语言转化成向量(或许可以视作语义).但模型得到的&quot;语义&quot;是动态的,在不同模型中不一样.</li></ul></li><li>获取信息和知识<ul><li>智能客服</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑与数字系统复习</title>
    <link href="/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/08/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>从零到一</h1><h2 id="进制">进制</h2><p>十进制: D<br>二进制: B<br>八进制: O<br>十六进制: H</p><h3 id="位置计数法">位置计数法</h3><p>R进制: $(N)<em>{R} = (K</em>{n-1}K_{n-2}…K_{1}K_{0}.K_{-1}K_{-2}…K_{-m})_{R}$</p><ul><li>多项式表示: $(N)<em>{R} =(\Sigma K</em>{i}*R^{i})_{R}$<ul><li>权: $R^{i}$</li><li>基数: R</li></ul></li></ul><h3 id="进制转换">进制转换</h3><ul><li>$\alpha \rightarrow 10 $</li><li>$10 \rightarrow \beta$<ul><li>整数部分: 基数除法</li><li>小数部分: 基数乘法<br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220830144318.png" alt="20220830144318" title="进制转换"></li></ul></li><li>$\alpha \rightarrow \beta \rightarrow 10$<ul><li>特殊情况: 16, 2, 8进制的相互转换</li></ul></li></ul><h2 id="编码">编码</h2><h3 id="补码">补码</h3><ul><li>二进制由原码获得补码的方法<ul><li>正数: 原码与补码相同.</li><li>负数: 由原码数值位取反加1获得, 符号位不变.</li></ul></li></ul><h3 id="增加位宽">增加位宽</h3><ul><li>零扩展<ul><li>将零一直拷贝到最高位</li><li>负数值发生变化</li></ul></li><li>符号位扩展<ul><li>将符号位一直拷贝到最高位</li><li>数值不变</li></ul></li></ul><h2 id="逻辑门">逻辑门</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220830145952.png" alt="单输入二输入逻辑门" title="单输入二输入逻辑门"><br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220830150031.png" alt="三输入或非门 与门" title="三输入或非门 与门"></p><h1>组合逻辑设计</h1><h2 id="概论">概论</h2><ul><li><p>组合逻辑电路</p><ul><li>任一时刻的输出仅由该时刻的输入信号决定</li><li>无记忆的, 与电路状态无关</li></ul></li><li><p>时序逻辑电路</p><ul><li>任一时刻的输出由该时刻的输入和电路该时刻的状态共同决定</li><li>有记忆的, 与电路状态有关</li></ul></li><li><p>组合逻辑电路</p><ul><li>每个电路模块都是一个组合逻辑电路</li><li>每个电路的输入只来自于一个节点的输出:<ul><li>每个电路结点或者是电路的输入或者是只连接电路模块的一个输出端</li></ul></li><li>电路中不包含回路</li></ul></li></ul><h1>时序逻辑设计</h1><h2 id="引言">引言</h2><ul><li>时序逻辑电路的输出由当前时刻的输入和之前时刻的输入共同决定</li><li>一些基本概念<ul><li>状态：用于解释电路未来行为所需的信息</li><li>锁存器与触发器：用于存储1比特状态的模块</li><li>同步时序逻辑电路：一类由组合逻辑和和一组表示电路状态的触发器所构成的电路</li></ul></li><li>时序逻辑电路特征<ul><li>按照一定的输入输出时序实现功能</li><li>电路内部具有短期记忆</li><li>在输出与输入之间具有反馈回路<br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220830202220.png" alt="时序逻辑电路" title="时序逻辑电路"></li></ul></li></ul><h2 id="时序问题">时序问题</h2><ul><li>D 触发器在时钟的有效边沿(上升沿/下降沿)对输入D采样, 并复制给Q. 此时D必须处在一个稳定的状态, 为0或为1, 否则会产生亚稳态.</li><li>建立时间: $t_{setup} = $  在时钟有效边沿到来前输入信号所需要的稳定时间</li><li>保持时间: $t_{hold} = $ 在时钟有效边沿到来后输入信号所保持稳定时间</li><li>孔径时间: $t_a = $在时钟边沿附近输入信号需要保持稳定的总时间</li><li>$t_a = t_{setup} + t_{hold}$<br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220831133055.png" alt="输入时序约束" title="输入时序约束"></li></ul><h1>指令集体系结构</h1><h2 id="MIPS指令类型">MIPS指令类型</h2><p>I型</p><ul><li>数据通路：完成对指令中操作数的运算、存储等处理工作</li><li>控制通路：从数据通路中接收指令，并对其进行翻译以告知数据通路如何处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2022/08/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/08/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>计算机网络和Internet</h1><h2 id="Internet层次型网络架构">Internet层次型网络架构</h2><h2 id="数据交换技术">数据交换技术</h2><h3 id="电路交换">电路交换</h3><ul><li>过程:<ul><li>建立连接</li><li>通信</li><li>释放连接</li></ul></li><li>电路交换的优点:<ol><li>能保证网络传输的性能：数据的传输速率, 端到端延迟.</li><li>传输过程中只要连接不中断, 就不会产生丢包, 也不会有乱序.</li></ol></li><li>电路交换的缺点:<ol><li>传输前要建立连接, 需要花费时间.</li><li>传输过程中一旦连接中断就要重新建立连接.</li><li>在网络容量固定的情况下, 只能允许固定数量的用户同时接入网络.超出上限的用户则不能接入网络(即有准入控制, admission control).</li></ol></li></ul><h3 id="分组交换">分组交换</h3><ul><li>基本原理:</li></ul><h2 id="性能评价参数">性能评价参数</h2><h3 id="延迟">延迟</h3><p>$d_{nodal} = d_{proc} + d_{prop} + d_{trans} + d_{queue}$</p><ul><li>延迟包括节点处理延迟$d_{proc}$, 传输延迟$d_{prop}$, 传播延迟$d_{trans}$和排队延迟$d_{queue}$.<ul><li>节点处理延迟通常可以忽略不计, 因为节点的计算能力越来越强大.</li><li>传输延迟 = 数据包长度L(bits) / 链路带宽R(bps).</li><li>传播延迟 = 链路两个节点间的物理距离d / 链路物理介质的传播速度s.</li><li>排队延迟和网络中的业务量有关, 是一个随时间变化的量.</li></ul></li></ul><h3 id="丢包率">丢包率</h3><ul><li>数据包在路由器排队等待转发，当转发的速度小于数据包到达的速度时，数据<br>包就会在路由器中排队。如果排队的数据包数量超过路由器缓冲区大小（缓冲<br>区满），后序到达的数据包就会被丢弃.</li></ul><h3 id="吞吐率">吞吐率</h3><ul><li>吞吐率: 在源端和目标端之间传输的速率（数据量/单位时间）.<ul><li>瞬间吞吐量: 在一个时间点的速率</li><li>平均吞吐量: 在一个长时间内平均值</li></ul></li><li>带宽时延积: 一条链路可以容纳的最大bit数量.<ul><li>带宽时延积 = 传输速率R * 传播延迟$d_{prop}$</li><li>一个比特宽度$=\frac{m}{R * d_{prop}} = \frac{m}{R * \frac{m}{s}} = \frac{s}{R}$</li></ul></li></ul><h2 id="Internet协议栈">Internet协议栈</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220825145540.png" alt="20220825145540" title="Internet协议栈"></p><ol><li>应用层：面向用户提供端到端的网络服务。</li><li>传输层：为应用层提供端到端的数据传输服务。</li><li>网络层：转发和路由。为数据包找到一条从源地址到目的地址的路径。</li><li>链路层：为共享同一条链路的多个用户分配链路资源，以便把数据包传输到网络层指定的相邻节点上。</li><li>物理层：负责把数字信号转换成模拟信号（光/电等），在物理介质上传输。</li></ol><h1>应用层</h1><h2 id="网络应用的体系架构">网络应用的体系架构</h2><h3 id="客户-服务器-C-S-架构">客户-服务器(C/S)架构</h3><ul><li>服务器:<ul><li>一直运行</li><li>IP地址和端口号固定</li><li>扩展性差</li></ul></li><li>客户端:<ul><li>主动与服务器通信</li><li>与互联网有间歇性的连接</li><li>可能是动态IP地址</li><li>不直接与其他客户端通信</li></ul></li></ul><h3 id="P2P架构">P2P架构</h3><h2 id="HTTP">HTTP</h2>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能基础复习</title>
    <link href="/2022/08/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/08/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1><strong>绪论</strong></h1><h2 id="人工智能的内涵与研究内容">人工智能的内涵与研究内容</h2><ul><li>人工智能: 用人工的方法在机器(计算机)上实现的智能;或者说是人们使机器具有类似于人的智能.</li><li>人工智能学科: 一门研究如何构造智能机器(智能计算机)或智能系统,使它能模拟, 延伸, 扩展人类智能的学科.</li><li>研究内容:<ul><li>知识表示</li><li>机器感知</li><li>机器思维</li><li>机器学习</li><li>机器行为</li></ul></li></ul><h2 id="三大学派及其代表工作">三大学派及其代表工作</h2><ul><li>符号主义学派: 知识表示, 启发式算法</li><li>联结主义学派: 人工神经网络</li><li>行为主义学派: Agent智能体</li></ul><h1><strong>问题求解</strong></h1><h2 id="搜索与状态空间">搜索与状态空间</h2><ul><li>状态: 表示系统状态, 事实等叙述性知识的一组变量或数组.<br>Q = [$q_{1}, q_2, …, q_n$$]^T$</li><li>操作: 表示引起状态变化的过程性知识的一组关系或函数:<br>F = ${f_{1}, f_{2}, …, f_{m} }$</li><li>状态空间: 利用状态变量和操作符号, 表示系统或问题的有关知识的符号体系, 状态空间是一个四元组:<br>$(S, O, S_{0}, G)$<ul><li>S: 状态集合.</li><li>O: 操作算子的集合.</li><li>$S_{0}$: 包含问题的初始状态, 是S的非空子集.</li><li>G: 若干具体状态或满足某些性质的路径信息描述.</li></ul></li><li>例: 八数码问题的状态空间.</li></ul><h2 id="启发式搜索">启发式搜索</h2><h3 id="启发式策略">启发式策略</h3><ul><li>启发式信息: 用来简化搜索过程有关具体问题领域的特性的信息叫做启发信息.</li><li>启发式图搜索策略: 重排OPEN表, 选择最优希望的节点加以扩展.</li><li>启发式搜索: 利用启发信息的搜索过程.</li><li>种类: $A, A^*$算法.</li></ul><h3 id="A算法">A算法</h3><p>A算法: 使用了估价函数f的最佳优先搜索.</p><ul><li>估价函数 $f(n)= g(n)+ h(n)$.<ul><li>$g(n)$: 状态n的实际代价,例如搜索的深度.</li><li>$h(n)$: 对状态n与目标&quot;接近程度&quot;的某种启发式估计.</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220822220936.png" alt="20220822220936" title="A算法流程图"></p><ul><li>八数码问题的A搜索算法:<ul><li>$g(n)$: 节点n的深度, 如$g(S_0)=0$.</li><li>$h(n)$: 节点n与目标状态不相同的位数(包括空格), 简称&quot;不在位数&quot;, 如$h(S_0)=5$.</li></ul></li></ul><h3 id="A-算法">$A^*$算法</h3><p>$A^<em>$算法: A算法满足$h(n)&lt;= h^</em>(n)$, 其中$h^*(n)$是状态n到目的状态的最优路径代价.</p><h1><strong>知识表示和知识图谱</strong></h1><h2 id="三段论">三段论</h2><p>所有的人都是会死的, 因为诸葛亮是人, 所以诸葛亮是会死的.<br>$(1) \forall x(Human(x) \rightarrow Die(x))  P规则$<br>$(2)Human(Zhugeliang)  P规则$<br>$(3)Die(Zhugeliang)  T规则$</p><h2 id="产生式规则">产生式规则</h2><h3 id="产生式系统">产生式系统</h3><ul><li>规则库: 用于描述相应领域内知识的产生式集合.</li><li>综合数据库(事实库、上下文、黑板等): 一个用于存放问题求解过程中各种当前信息的数据结构.</li><li>控制系统(推理机构): 由一组程序组成, 负责整个产生式系统的运行，实现对问题的求解.</li></ul><h3 id="流程">流程</h3><p>从规则库中取出$r1$, 检查其前提是否可与综合数据库中的已知事实匹配. 匹配失败则$r1$不能被用于推理. 然后取$r2$进行同样的工作。匹配成功则$r2$被执行.</p><h2 id="知识图谱及其应用">知识图谱及其应用</h2><ul><li>知识图谱(Knowledge Graph/Vault): 用各种不同的图形等可视化技术描述知识资源及其载体, 挖掘, 分析, 构建, 绘制和显示知识及它们之间的相互联系.</li><li>知识图谱三要素: 实体, 关系, 属性.</li><li>应用: 维基百科, DBpedia, YAGO, XLORE, 搜索引擎.</li></ul><h1><strong>专家系统</strong></h1><p>专家系统产生的标志性事件: <s>1968年斯坦福大学费根鲍姆等人研制成功分析化合物分子结构的专家系统——DENDRAL系统.</s><br>1977年第五次IJCAI国际人工智能联合会议, 费根鲍姆系统性地提出了专家系统的概念.</p><blockquote><p>费根鲍姆(E. A. Feigenbaum):<br>“专家系统是一种智能的计算机程序，它运用知识和推理来解决只有专家才能解决的复杂问题。”</p></blockquote><ul><li>专家系统: 一类包含知识和推理的智能计算机程序.</li></ul><h2 id="机器学习">机器学习</h2><p>机器学习：机器学习使计算机能模拟人的学习行为, 自动地通过学习来获取知识和技能, 不断改善性能, 实现自我完善.</p><h2 id="数据挖掘">数据挖掘</h2><ul><li>知识发现: 从数据库中发现知识(KDD).</li><li>数据挖掘(DM): 从数据库中挖掘知识.</li></ul><h1><strong>人工神经网络</strong></h1><h2 id="神经网络如何表示与或逻辑">神经网络如何表示与或逻辑</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220823193718.png" alt="20220823193718" title="与逻辑"><br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220823193757.png" alt="20220823193757" title="或逻辑"></p><h2 id="BP神经网络">BP神经网络</h2><h3 id="前向计算方法">前向计算方法</h3><p>$ u_{i}^{k} = \sum_{j}w_{ij}^{k-1}y_{j}^{k-1}$<br>$ y_{i}^{k} = f_{k}(u_{i}^{k}) $</p><h3 id="反向调整方法">反向调整方法</h3><p>$\Delta w_{ij}^{k-1} = - \varepsilon d_{i}^{k} y_{j}^{k-1}$</p><p>$d_{i}^{m} = y_{i}^{m}(1-y_{i}^{m})(y_{i}^{m} - y_{si}) = (y_{i}^{m} - y_{si})f_{m}^{'}(u_{i}^{m})$</p><p>$d_{i}^{k} = y_{i}^{k}(1-y_{i}^{k})\Sigma_{i}d_{l}^{k+1}w_{li}^{k} = f_{k}^{'}(u_{i}^{k})\Sigma_{l}d_{l}^{k+1}w_{li}^{k}    (k = m-1, …, 2)$</p><h2 id="卷积神经网络">卷积神经网络</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.gif" alt="卷积神经网络"></p><h1><strong>计算智能</strong></h1><h2 id="遗传算法">遗传算法</h2><ul><li>遗传算法(genetic algorithms, GA): 一类借鉴生物界自然选择和自然遗传机制的随机搜索算法, 非常适用于处理传统搜索方法难以解决的复杂和非线性优化问题.</li><li>设计流程:<br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/20220818213220.png" alt="20220818213220" title="遗传算法设计流程"></li></ul><h2 id="轮盘赌">轮盘赌</h2><p>(考代码)</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">RouletteWheelSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义rand触发随机值得初始值</span>    <span class="token keyword">double</span> m<span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">double</span><span class="token punctuation">(</span>RAND_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//产生一个[0,1)的随机值；</span>    <span class="token keyword">int</span> Probability_Total<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> Selection<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>SIZE<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//SIZE是个体数量的大小   </span>    <span class="token punctuation">&#123;</span>        Probability_Total<span class="token operator">=</span>Probability_Total<span class="token operator">+</span>Probability<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Probability_Total<span class="token operator">>=</span>m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            Selection<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Selection<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1><strong>多智能体系统</strong></h1><h2 id="Agent和多Agent系统">Agent和多Agent系统</h2><ul><li>Agent可以看做是一个程序或者一个实体, 它嵌入在环境中, 通过传感器(sensors)感知环境, 通过效应器(effectors)自治地作用于环境并满足设计要求.</li><li>多智能体系统(MAS): 一个应用系统中包含多个智能体, 其中的智能体不仅具备自身的问题求解能力和行为目标, 而且能够互相协作, 达到共同的整体目标, 这样的系统成为多智能体系统.<ul><li>其中每个智能体具有独立性和自主性.</li><li>MAS支持分布式应用，具有良好的模块性.</li><li>MAS按面向对象的方法构造多层次、多元化的智能体.</li><li>MAS是一个协调式的系统，也是一个集成系统.</li><li>在MAS中，智能体之间相互通讯，彼此协调，并行地求解问题，提高了问题求解效率.</li><li>同一个MAS中各个智能体可以是异构的.</li><li>在MAS中，不同领域的专家系统、同一领域不同的专家系统可以协作求解单一专家系统难以解决的问题.</li></ul></li><li>四要素: 通信, 协调, 协作, 协商.</li></ul><h2 id="Agent设计方案">Agent设计方案</h2><p>以火星车为例：</p><ul><li>问题：<ul><li>火星探测器在火星上收集岩石样本并把样本运回基地.</li><li>岩石的位置未知.</li><li>探测器可以接收到基地发出的无线电信号.</li></ul></li><li>解决方案:<ol><li>如果发现障碍物,则改变方向.</li><li>如果处于基地并且携带着样本,则放下样本.</li><li>如果携带着样本且不在基地, 则往无线电信号增强的方向移动.</li><li>如果检测到样本, 则采集样本.</li><li>随机移动.</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并行计算复习</title>
    <link href="/2022/06/06/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/06/06/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1><strong>并行计算基本概念</strong></h1><ul><li>什么是并行计算<br>同时使⽤多种计算资源解决计算问题的过程, 是提⾼计算机系统计算速度和处理能⼒的⼀种有效⼿段.</li><li>为什么需要并行计算<ol><li>为了满足不断增长的计算力的需求，比如天气预报等任务精度提高和大数据时代数据量的提升要求算力提高.</li><li>计算机硬件和网络技术的发展，导致多核处理器的广泛应用，使得程序需要支持并行计算.</li><li>单核处理器性能提升有限，不能满足增长的算力需求.</li><li>IO处理速度慢.</li></ol></li><li>三种经典的并行化方法<ol><li>域分解<br>将数据划分成多个子数据, 将子数据分配给多个处理器同时运行。</li><li>任务分解<br>将任务从功能角度分成多个子任务分配给处理器, 然后将数据分配到处理相应任务的处理器并行运行.</li><li>流水线<br>一类特殊的任务分解方式, 将一个任务分解成多个子任务同时进行, 在多个不同数据执行相同任务时性能提升较为明显.</li></ol></li></ul><h1><strong>并行计算的性能测评</strong></h1><h2 id="并行计算的性能">并行计算的性能</h2><h3 id="性能指标">性能指标</h3><ul><li>performance: 通常是指机器的速度, 它是程序执行时间的倒数</li><li>程序执行时间：是指用户的响应时间(包括访问磁盘和访问存储器的时间, CPU时间, I/O时间以及操作系统的开销)</li><li>CPU时间：它表示CPU的工作时间, 不包括I/O等待时间和运行其它任务的时间.</li><li>加速比: 串行执行时间与并行执行时间之比<br><font size=5>S(n) = $\frac{Executiontime(one processor system)}{Executiontime(multiprocessor system)}$ = $\frac{t_{s}}{t_{p}}$</font></li><li>计算/通信比:<br><font size=5>$\frac{Computation Time}{Communication Time}$ = $\frac{t_{comp}}{t_{comm}}$ </font></li><li>开销:<ul><li>部分处理器的空闲</li><li>并行版本中所需的顺序计算中不会出现的额外计算</li><li>发送消息所需的通信时间</li></ul></li><li>效率:<br><font size=5>E = $\frac{t_{s}}{t_{p} * n}$ = $\frac{S(n)}{n}$ </font></li></ul><h2 id="内存对性能的影响">内存对性能的影响</h2><p>内存系统的性能包括延迟和带宽两个方面:</p><ul><li>延迟指处理器向内存发起访问直至获取数据所需要的时间</li><li>带宽指内存系统向处理器传输数据的速率。</li></ul><p>处理器执行指令时，由于CPU速度远快于IO存取（即延迟），导致指令执行的时间取决于延迟的大小。为了减小延迟，可以采用高速缓存.<br>带宽决定了单位时间内可以读取数据的大小，带宽增加可以减少读取数据的次数，可以提升峰值的速度，但对延迟大小没有影响.</p><h2 id="加速比定律">加速比定律</h2><p>定义以下参数:</p><ul><li>P: 处理器数</li><li>W: 问题规模(计算负载, 工作负载, 给定问题的总计算量):<ul><li>$W_{s}$:  应用程序中的串行分量, f是串行分量比例(f = $\frac{W_{s}}{W}$).</li><li>$W_{p}$: 应用程序中可并行化部分, 1-f为并行分量比例.</li><li>$W_{s}$ + $W_{p}$ = W.</li></ul></li><li>$T_{s}$: 串行执行时间, $T_{p}$ : 并行执行时间.</li><li>S: 加速比, E:效率.</li><li>代价cost:<br>代价 = 执行时间$t_{p}$ * 所使用的处理器整数n.<ul><li>对于串行计算:<ul><li>代价 = 执行时间$t_{s}$.</li></ul></li><li>对于并行计算:<ul><li>$t_{p} = \frac{t_{s}}{S(n)}$.</li><li>代价 = $t_{p} * n = \frac{t_{s}}{S(n)} = \frac{t_{s}}{E}$.</li></ul></li></ul></li></ul><h3 id="Amdahl-定律">Amdahl 定律</h3><ul><li>出发点:<ul><li>固定不变的计算负载.</li><li>固定的计算负载分布在多个处理器上的.</li><li>增加处理器加快执行速度，从而达到加速的目的.</li></ul></li><li>公式:<br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/Amdahl%E5%AE%9A%E5%BE%8B.png" alt="公式" title="Amdahl 定律公式"></li><li>结论:<br>给定一个应用，不断增加并行计算机和处理器数目，不可能无限制的提升加速比.</li></ul><h3 id="Gustafson-定律">Gustafson 定律</h3><ul><li>出发点:<ul><li>大型计算中要求高精度, 同时计算时间不变, 所以需要相应地增多处理器数.</li><li>增多处理器必须相应地增大问题规模才有实际意义.</li></ul></li><li>公式:<br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/Gustafson%E5%AE%9A%E5%BE%8B.png" alt="公式" title="Gustafson 定律公式"></li><li>结论:<br>给定一个应用，不断增加并行计算机和处理器数目，可以无限制的提升加速比.</li></ul><h3 id="Sun-and-Ni-定律">Sun and Ni 定律</h3><p>Sun-Ni定律是对前两个定律的总括和扩展.</p><ul><li>出发点:<ul><li>只要存储空间允许, 应当尽量增大问题规模以产生更好和更精确的解.</li><li>假定在单节点上使用了全部存储容量M并在相应于W的时间内求解之，此时工作负载W = fW + (1 - f)W.</li><li>设置因子G(p)表示存储容量增加到p倍时并行工作负载的增加量, 所以扩大后的工作负载W = fW + (1-f)G(p)W.</li></ul></li><li>存储受限的加速公式:<br><font size=5>$S^{&quot;} = \frac{fW + (1 - f)G(p)W}{fW + \frac{(1 - f)G(p)W}{p}} = \frac{f + (1 - f)G(p)}{f + \frac{(1 - f)G(p)}{p}}$</font></li><li>并行开销:<br><font size=5>$S^{'} = \frac{fW + (1 - f)G(p)W}{fW + \frac{(1 - f)G(p)W}{p} + W_{O}} = \frac{f + (1 - f)G(p)}{f + \frac{(1 - f)G(p)}{p} + \frac{W_{O}}{W}}$</font></li></ul><h2 id="可扩放性评测">可扩放性评测</h2><ul><li>可扩放性(Scalability)<br>计算机系统(或算法或程序等)性能随处理器数的增加而按比例提高的能力, 反映并行算法能否有效利用可扩充PE数的能力.</li><li>影响加速比的因素：处理器数与问题规模<ul><li>求解问题中的串行分量</li><li>并行处理所引起的额外开销（通信、等待、竞争、冗余操作和同步等）</li><li>加大的处理器数超过了算法中的并发程度</li></ul></li><li>增加规模有利于提高加速比的因素：<ul><li>较大的问题规模可以提高较高的并发度</li><li>额外开销的增加可能慢于有效计算的增加</li><li>算法中的串行分量比例不是固定不变的(因问题规模增加而缩小)</li></ul></li></ul><h1><strong>MPI编程和Mapreduce编程</strong></h1><p>考试都考完了, 这一部分和其他没总结好的部分就鸽了(逃).</p><h1>并行算法的一般设计策略</h1><h2 id="串行算法的直接并行化">串行算法的直接并行化</h2><ul><li>方法: 发掘和利用现有并行算法的并行性,直接将串行算法改造为并行算法.</li><li>特点:<ul><li>由串行算法直接并行化的方法是并行算法设计的最常用方法之一.</li><li>不是所有的串行算法都可以直接并行化.</li><li>一个好的串行算法未必能并行化为一个好的并行算法.</li><li>许多数值串行算法可以并行化为有效的数值并行算法.</li></ul></li></ul><h3 id="积分算法的直接并行化–π的计算">积分算法的直接并行化–π的计算</h3><h3 id="排序">排序</h3><ul><li>枚举排序</li><li>冒泡排序并行化–奇偶排序</li></ul><h3 id="矩阵转置-点乘与数乘">矩阵转置, 点乘与数乘</h3><h2 id="从问题描述开始设计并行算法">从问题描述开始设计并行算法</h2><ul><li>方法: 从问题本身描述出发，不考虑相应的串行算法，设计一个全新的并<br>行算法.</li><li>特点:<ul><li>挖扼问题的固有特性与并行的关东.</li><li>设计全新的并行算法是一个挑战性和创造性的工作.</li></ul></li></ul><h3 id="求前缀和">求前缀和</h3><p>年年必考填空.</p><h2 id="借用已有算法求解新问题">借用已有算法求解新问题</h2><ul><li>方法: 找出求解问题和禁个已解决问题之间的联系, 改造或利用已知算法应用列求解问题上.</li><li>特点:<ul><li>这是一项创造性的工作(好水的一句词…).</li></ul></li></ul><h1>碎碎念</h1><p>很遗憾直到考试结束也没有把并行计算的内容复习完, 好几道题都没有背会, 最后得了85分…<br>据老哥们说这课给分不高来着, 好像蛮多70+的, 不过就我在家的复习状态高不高的也就认了.</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ParallelComputing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 Chapter3 传输层</title>
    <link href="/2022/04/11/Transport_Layer/"/>
    <url>/2022/04/11/Transport_Layer/</url>
    
    <content type="html"><![CDATA[<h3 id="Transport-Services"><strong>Transport Services</strong></h3><p>传输层使用网络层的服务, 向应用层提供逻辑上的端到端的数据传输.</p><ul><li><p>TCP： Transmission Control Protocol<br>面向连接, 可靠 有序, 有拥塞控制, 流量控制和连接管理</p></li><li><p>UDP： User Datagram Protocol<br>不可靠, 乱序, 只是封装和解封装</p></li></ul><p>上述两种标准都不能确保延迟(delay)和带宽(bandwidth).<br>由于分组交换中每个数据包都在独立寻址, 所以先发出的数据包可能会晚到, 会出现乱序和丢包.<br>应用层(Application Layer)中, 不同应用对于数据完整性, 延迟和吞吐量throughput以及安全性要求不一样, 这样就会采用不同的传输层标准.</p><h3 id="UDP-User-Datagram-Protocol"><strong>UDP User Datagram Protocol</strong></h3><ul><li>无连接, 导致可能有丢包和乱序, 同时也会减少一个RTT时间的消耗.</li><li>简单,不需要在sender和receiver之间维护连接的状态.</li><li>header的size小. 相对开销减少, 效率高.</li><li>无拥塞控制(比较直接的方案是减小client端的发送速度, 调节吞吐率).<br>相对于有拥塞控制的TCP, UDP会尽量快地发送数据,没有限速.</li></ul><p>UDP的header只有4个域:source port, dest port, length(UDP segment的长度)和checksum.</p><h3 id="RDT-reliable-data-transfer"><strong>RDT reliable data transfer</strong></h3><p>server端和client端只能通过接收到的对方发送的数据包才能知道对方的状态(state).</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑与数字系统 Chapter2 组合逻辑设计</title>
    <link href="/2022/03/24/%E6%95%B0%E5%AD%90%E7%94%B5%E8%B7%AF_1/"/>
    <url>/2022/03/24/%E6%95%B0%E5%AD%90%E7%94%B5%E8%B7%AF_1/</url>
    
    <content type="html"><![CDATA[<h2 id="推气泡"><strong>推气泡</strong></h2><p>可以通过与非门和或非门实现所有的逻辑电路. 这样可以减少硬件, 但会造成电路不易阅读. 可以通过推气泡的方法推导电路表达式.</p><ul><li>向后推: 气泡从输出端变到输入端,与门变或门,或门变与门</li><li>向前推: 气泡从输入端变到输出端,与门变或门,或门变与门<br>两个相邻气泡可以相互抵消.</li></ul><h3 id="推气泡的方法">推气泡的方法</h3><p>从输出端向输入端推.<br>将气泡从电路最后的输出端开始推.<br>如果当前门有一个输入气泡, 可以变为前一个门的输出气泡.(即气泡可以在电路上门之间流动)</p><h2 id="X-和-Z"><strong>X 和 Z</strong></h2><p>竞争(Contention)指电路结点同时被0和1驱动,这时结点的值并不确定, 定义为非法值X.<br>无关项X表示输出不需要考虑的输入,主要应用于优先级电路中.</p><h2 id="组合逻辑的时序"><strong>组合逻辑的时序</strong></h2><p>电路中输出响应输入的改变需要一定时间.</p><h3 id="传播延迟和最小延迟">传播延迟和最小延迟</h3><p>传播延迟: t pd<br>输入改变直到一个或多个输出改变为最终值所需的最长的时间延迟.</p><p>最小延迟: t cd:<br>输入发生变化直到任何一个输出开始改变的最短时间.</p><p>关键路径: 信号传输最慢的一条路径.  计算时取最长路径的tpd.<br>最短路径: 信号通过最快的路径.  计算式取最短路径的tcd.</p><h3 id="毛刺">毛刺</h3><ul><li>当信号的变化在卡诺图中穿越2个主蕴含项的边缘时会出现毛刺.<ul><li>通过在卡诺图中增加多余的蕴含项来盖住这些边缘以避免毛刺</li></ul></li><li>多个输入（几乎）同时变化也会产生&quot;毛刺&quot;<ul><li>这些不能通过增加硬件来避免</li></ul></li><li>毛刺在大多数电路中都存在</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A Day3 yield</title>
    <link href="/2022/02/23/CS61A-Day3/"/>
    <url>/2022/02/23/CS61A-Day3/</url>
    
    <content type="html"><![CDATA[<h2 id="yield-关键字"><strong>yield 关键字</strong></h2><p>带有yield关键字的函数称为生成器(generator), 有以下代码:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fab</span><span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>     <span class="token keyword">while</span> n <span class="token operator">&lt;</span> <span class="token builtin">max</span><span class="token punctuation">:</span>         <span class="token keyword">yield</span> b      <span class="token comment"># 使用 yield</span>        <span class="token comment"># print b </span>        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b         n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> fab<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>首先yield起到return的作用, 使函数终止并返回值. 但和return有一点不同, return后函数终止并且销毁局部变量; 而yield返回可迭代的generator(生成器)对象. 即在下一次运行该生成器对象时, 从yield的下一行继续执行, 直到yield.  <br/><br/><br>上面的代码是斐波那契的yield写法, 通过简述其执行过程, 可以大致理解yield的作用.   <br/><br/><br>在for循环中, 调用fab(5)并不会执行函数,而是返回的迭代器(iterable)或者生成器. 在循环中, 第一次迭代执行到yield b, 返回b的值, 下一次迭代从yield的下一行a, b = b, a + b开始执行, 直到再一个yield b.<br>输出结果为:<br><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/yield%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png" alt="输出结果" title="yield 斐波那契输出结果"></p><h3 id="yield-相关方法"><strong>yield 相关方法</strong></h3><ul><li>next( )</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>f <span class="token operator">=</span> fab<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">2</span> <span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">3</span> <span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span> StopIteration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>对generator(生成器)调用next( ), 过程和结果如上. <br/><br/><br>f 是返回的可迭代的生成器对象, next( )是对函数进行一次执行, 类似上面的一次迭代.</p><ul><li>send( )<br>有以下代码:</li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"starting..."</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token number">4</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"res:"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>g <span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token operator">*</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>输出结果<span class="token punctuation">:</span>  starting<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span>res<span class="token punctuation">:</span> <span class="token number">7</span><span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>由于yield会直接返回4并终止此次迭代, 在下一次迭代时res由于并没有成功赋值, 所以print出来的是None.  <br/><br/><br>send( )方法就是用参数替代原本yield的地方, 所以在*线之下, res被赋值为7.</p><h2 id="参考资料">参考资料</h2><ul><li>Python yield 使用浅析<br><a href="https://www.runoob.com/w3cnote/python-yield-used-analysis.html">https://www.runoob.com/w3cnote/python-yield-used-analysis.html</a></li><li>python中yield的用法详解——最简单，最清晰的解释<br><a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></li><li>如何理解Python中的yield用法?<br><a href="https://zhuanlan.zhihu.com/p/268605982">https://zhuanlan.zhihu.com/p/268605982</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A Day2 dictionary</title>
    <link href="/2022/01/18/CS61A-Day2/"/>
    <url>/2022/01/18/CS61A-Day2/</url>
    
    <content type="html"><![CDATA[<h2 id="dict-字典"><strong>dict 字典</strong></h2><p>dict是python内置的一种和list tuple相区别的数据结构, 即c\c++的map,通过键-值(key-value)存储, 通过hash查找来访问. 比如</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'Michael'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">:</span> <span class="token number">75</span><span class="token punctuation">,</span> <span class="token string">'Tracy'</span><span class="token punctuation">:</span> <span class="token number">85</span><span class="token punctuation">&#125;</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'Michael'</span><span class="token punctuation">]</span><span class="token number">95</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>上例中, 'Michael’即是key, 95是它的value.<br/><br/><br>将元素放入dict可以按照上例在初始时定义，也可以有如下加入元素的方法:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'Adam'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">67</span><span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'Adam'</span><span class="token punctuation">]</span><span class="token number">67</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>由于采用hash散列存放和查找，所以dict在内存存放的顺序和放入dict的顺序没有关系. <br/><br/><br>因此，dict相较于list会占用更多的内存, 并且key必须是不可变的对象, 如数字, 字符串和元组, 而list就不能作为dict的key.  <br/><br/><br>删除dict的元素时可以有以下方法</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">del</span> tinydict<span class="token punctuation">[</span><span class="token string">'Name'</span><span class="token punctuation">]</span>  <span class="token comment"># 删除键是'Name'的条目</span>tinydict<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment"># 清空字典所有条目, 此时为一空dict</span><span class="token keyword">del</span> tinydict          <span class="token comment"># 删除字典</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>dict 还有一些内置的函数方法，包括items( ), keys( ), values( )等，菜鸟教程有详细的描述</p><h2 id="比较dict中value的最大值和最小值">比较dict中value的最大值和最小值</h2><p>有以下dict,想要求其中value最小的元组</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token builtin">min</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>和其他调用min( )不太一样，这里是从d.items( )中取出第一个元素(即第一个元组)作为x, 进入匿名函数中, 返回其value, 后面相同直到dict最后. 最终min( )中的是[(1, 5), (2, 3), (3, 4)].  <br/><br/><br>下面几行代码就是应用上面的方法来按value升序输出元组:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dict_to_lst</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Returns a list containing all the (key, value) pairs in d as two-element    tuples ordered by increasing value.    >>> nums = &#123;1: 5, 2: 3, 3: 4&#125;    >>> dict_to_lst(nums)    [(2, 3), (3, 4), (1, 5)]    >>> words = &#123;'first': 'yes', 'second': 'no', 'third': 'perhaps'&#125;    >>> dict_to_lst(words)    [('second', 'no'), ('third', 'perhaps'), ('first', 'yes')]    """</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        pair <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        d<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>pair<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pair<span class="token punctuation">)</span>    <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>看完应用再来回顾一下min函数的定义:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># known special case of min</span>    <span class="token triple-quoted-string string">"""    min(iterable, *[, default=obj, key=func]) -> value    min(arg1, arg2, *args, *[, key=func]) -> value        With a single iterable argument, return its smallest item. The    default keyword-only argument specifies an object to return if    the provided iterable is empty.    With two or more arguments, return the smallest argument.    """</span>    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>可以看到:</p><ul><li>在参数key为空时, 比较args的内容, 如果args为可迭代的对象如list, tuple, dict, 则会迭代后返回其中最小的元素.  <br/><br/></li><li>在参数key不为空时，对于可迭代的args，先进入迭代，对每次迭代得到的元素放入key参数(是一个fuction)后得到的值进行min操作.</li></ul><h2 id="参考资料">参考资料</h2><ul><li>廖雪峰的python教程dict<br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448">https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448</a></li><li>Python学习手册(第四版) p220-236</li><li>菜鸟教程 dict<br><a href="https://www.runoob.com/python/python-dictionary.html">https://www.runoob.com/python/python-dictionary.html</a></li><li>python四个带 key 参数的函数（max、min、map、filter）<br><a href="https://www.cnblogs.com/bigtreei/p/7823205.html">https://www.cnblogs.com/bigtreei/p/7823205.html</a><br>内置函数：min 用法<br><a href="https://www.cnblogs.com/bigtreei/p/7823266.html">https://www.cnblogs.com/bigtreei/p/7823266.html</a></li><li>python 使用 max函数求字典的最大值（lambda表达式）<br><a href="https://blog.csdn.net/sinat_38068807/article/details/86021686">https://blog.csdn.net/sinat_38068807/article/details/86021686</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS61A Day1 lambda 递归</title>
    <link href="/2022/01/13/CS61A-Day1/"/>
    <url>/2022/01/13/CS61A-Day1/</url>
    
    <content type="html"><![CDATA[<h2 id="lambda-匿名函数"><strong>lambda 匿名函数</strong></h2><p>lambda的形式如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">lambda</span> <span class="token punctuation">[</span>arg1 <span class="token punctuation">[</span><span class="token punctuation">,</span>arg2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>argn<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>可以发现,lambda就是以arg1直到argn(如果有那么多变量的话),返回expression，expression是该匿名函数的函数体和返回值.比如</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">act <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">+</span> <span class="token number">1</span>act<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure><p>就是将这个匿名函数赋值给act, act(3) = 3 + 1 = 4.</p><p>对于嵌套的lambda ,如</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">action <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token keyword">lambda</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> yact <span class="token operator">=</span> action<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span>act<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure><p>这个就相当于下面的def形式</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">action</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token keyword">lambda</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> yact <span class="token operator">=</span> action<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span>act<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>而如果想要直接调用action来计算,则需要写成action(99)(3)的形式<br>再举一通过匿名函数实现递归阶乘例</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">make_anonymous_factorial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Return the value of an expression that computes factorial.    >>> make_anonymous_factorial()(5)    120    >>> from construct_check import check    >>> check(HW_SOURCE_FILE, 'make_anonymous_factorial', ['Assign', 'AugAssign', 'FunctionDef', 'Recursion'])    True    """</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> f<span class="token punctuation">:</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> f<span class="token punctuation">(</span>f<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> f<span class="token punctuation">,</span> x<span class="token punctuation">:</span> x <span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">else</span> x <span class="token operator">*</span> f<span class="token punctuation">(</span>f<span class="token punctuation">,</span> x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>返回值中，(lambda f, x: x if x == 1 else x * f(f, x-1))是前一部分的嵌套匿名函数(lambda f: lambda x: f(f, x))中的参数f，所以调用make_anonymous_factor( )时后面只需要输入参数x</p><h2 id="Higher-Order-Functions-高阶函数"><strong>Higher Order Functions 高阶函数</strong></h2><p>首先，需要知道在python中函数名同样是一个变量.比如add( ),其返回值是将各参数之和，而如果有</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> func <span class="token operator">=</span> add<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>则可以像调用add(x, y)一样调用func(x, y).<br>同样的,函数名也可以作为传入函数的参数和返回值</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">trace1</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">wrapped</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-> '</span><span class="token punctuation">,</span> fn<span class="token punctuation">,</span> <span class="token string">'('</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token string">')'</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> fn<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapped<span class="token operator">>></span><span class="token operator">></span> @trace1    <span class="token keyword">def</span> <span class="token function">triple</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">3</span> <span class="token operator">*</span> x<span class="token operator">>></span><span class="token operator">></span> triple<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>  <span class="token operator">&lt;</span>function triple at <span class="token number">0x102a39848</span><span class="token operator">></span> <span class="token punctuation">(</span> <span class="token number">12</span> <span class="token punctuation">)</span><span class="token number">36</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>trace1( )是一个高阶函数, 返回值是wrapped( ), 假如有</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> func <span class="token operator">=</span> trace1<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>那么会先执行trace1( ) 中return前的code, 并有func = wrapped, func(x) = wrapped(x)<br>对于triple(x), 其不仅是一个def, 并且有一个<em>注释</em>, 调用triple相当于</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">triple <span class="token operator">=</span> trace1<span class="token punctuation">(</span>triple<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>另外，如果是一个多层嵌套的高阶函数，如果内层的函数试图引用外层的函数定义和声明的变量n, 在不修改n的值的情况下可以直接调用  <br/><br/><br>如果内层函数需要对n进行修改,则需要在内层函数里有以下声明</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">nonlocal</span> n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>如下例:</p><figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">make_adder_inc</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    >>> adder1 = make_adder_inc(5)    >>> adder2 = make_adder_inc(6)    >>> adder1(2)     7    >>> adder1(2) # 5 + 2 + 1    8    >>> adder1(10) # 5 + 10 + 2    17    >>> [adder1(x) for x in [1, 2, 3]]    [9, 11, 13]    >>> adder2(5)    11    """</span>    <span class="token string">"*** YOUR CODE HERE ***"</span>    m <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">nonlocal</span> m        m <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> n <span class="token operator">+</span> x <span class="token operator">+</span> m    <span class="token keyword">return</span> func<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="参考资料">参考资料</h2><ul><li>廖雪峰的python教程函数式编程部分<br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017328525009056">https://www.liaoxuefeng.com/wiki/1016959663602400/1017328525009056</a></li><li>SICP python描述 1.6高阶函数<br><a href="https://wizardforcel.gitbooks.io/sicp-py/content/1.6.html">https://wizardforcel.gitbooks.io/sicp-py/content/1.6.html</a></li><li>Python学习手册(第四版) p483-488</li><li>CS61A lab 02<br><a href="https://inst.eecs.berkeley.edu/~cs61a/su19/lab/lab02/">https://inst.eecs.berkeley.edu/~cs61a/su19/lab/lab02/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>CS61A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS 进程习题部分记录</title>
    <link href="/2021/12/02/%E8%BF%9B%E7%A8%8B%E4%B9%A0%E9%A2%98/"/>
    <url>/2021/12/02/%E8%BF%9B%E7%A8%8B%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>若某单处理器多进程系统中有多个就绪态进程，在进程处于临界区时能否进行处理机调度？  <br/><br/><ul><li>可以，当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的。比如，通常访问临界资源可能是慢速的外设（如打印机），如果在进程访问打印机时，不能处理机调度，那么系统的性能将是非常低的。 <br/><br/></li><li>几种不适合进行处理机调度的情况：①在处理中断的过程中；②进程在操作系统内核程序临界区中；③其他需要完全屏蔽中断的原子操作过程中。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>homework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.S081 lab1 Xv6_utilities</title>
    <link href="/2021/10/20/6.S081_lab1/"/>
    <url>/2021/10/20/6.S081_lab1/</url>
    
    <content type="html"><![CDATA[<p>pipe结构如下</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PIPESIZE</span> <span class="token expression"><span class="token number">512</span></span></span><span class="token keyword">struct</span> <span class="token class-name">pipe</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> lock<span class="token punctuation">;</span>  <span class="token keyword">char</span> data<span class="token punctuation">[</span>PIPESIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  uint nread<span class="token punctuation">;</span>     <span class="token comment">// number of bytes read</span>  uint nwrite<span class="token punctuation">;</span>    <span class="token comment">// number of bytes written</span>  <span class="token keyword">int</span> readopen<span class="token punctuation">;</span>   <span class="token comment">// read fd is still open</span>  <span class="token keyword">int</span> writeopen<span class="token punctuation">;</span>  <span class="token comment">// write fd is still open</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p>在pipe(fd)后，fd[2]数组已不再是一般的有两个元素的int型数组，调用write函数写入fd[1]中的数据都会传到管道并存入缓冲区</p><h1><strong>1.Sleep函数</strong></h1><h2 id="（1）实验目的">（1）实验目的</h2><p>实现一条指令，使xv6可以暂停相应参数的ticks（tick为xv6的一个时间单位），输入格式为sleep 10。</p><h2 id="（2）实验步骤">（2）实验步骤</h2><p>要求在user/sleep.c中实现，故新建sleep.c文件。在user.h文件中有可以调用的函数，根据要求，此处只需要根据输入格式“sleep 第一个参数”调用atoi函数和sleep函数，第一个参数为sleep的ticks。由于是按char*格式传入的参数，需要调用atoi函数来转换成int型参量。</p><h2 id="（3）实验代码">（3）实验代码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//sleep fuction</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">atoi</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error! Please input the number of ticks.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>        num <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error! You input too much argument or no argument.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1><strong>2.Pingpong函数</strong></h1><h2 id="（1）实验目的-2">（1）实验目的</h2><p>在进程之间创建管道实现通信，使父进程向子进程发送ping，如果接收成功则子进程输出“<pid>: received ping”，子进程向父进程发送png，如果接收成功则父进程输出“<pid>: received pong”。</p><h2 id="（2）实验步骤-2">（2）实验步骤</h2><p>Pipe函数定义如下<br><code>int pipe(int fd[2]);</code><br>分别建立两个有两个元素的int型数组fd_pa[2]和fd_ch[2]作为父进程和子进程之间通信的管道，其中[0]用于读取，[1]用于写入。Pipe函数调用由于fork( )在子进程中返回值为0，而在父进程中返回值为子进程的pid（大于0），则可以由此区分情况，分别调用write( )和read( )进行写入和读取即可。输出时要求输出相应进程的pid，调用getpid( )即可。<br>此处子进程中应当先read到fd_pa之中的“ping”之后再向fa_ch进行write，不然出现奇怪的bug。</p><h2 id="（3）实验代码-2">（3）实验代码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//pingpong fuction</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token comment">// #include "kernel/pipe.c"</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd_pa<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fd_ch<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//written by parent and child</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>fd_pa<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">pipe</span><span class="token punctuation">(</span>fd_ch<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fail to create pipe\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">write</span><span class="token punctuation">(</span>fd_pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"ping"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"ping"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">read</span><span class="token punctuation">(</span>fd_ch<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"pong"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received %s\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">read</span><span class="token punctuation">(</span>fd_pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"ping"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received %s\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">write</span><span class="token punctuation">(</span>fd_ch<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"pong"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"ping"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fail to create process\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1><strong>3.Primes函数</strong></h1><h2 id="（1）实验目的-3">（1）实验目的</h2><p>通过pipe( ) 和fork( )来设置管道，以实现埃氏筛法来寻找不大于35的素数,输入为”primes”</p><h2 id="（2）实验步骤-3">（2）实验步骤</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/pipe.jpg" alt="筛法" title="埃氏筛法"><br>思路即如图所示，每一次选取管道中第一个数作为base，剩下的数如果可以整除base则被筛掉，余下的数进行下一次筛，直到只剩下一个数。每次的base即为筛得的质数。</p><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/pipe_struct.jpg" alt="pipe" title="pipe结构体"><br>首先将大于等于2且小于等于35的整数输入管道中（在调用pipe函数之后，fd实际是形成了一个pipe的结构，写入fd[1]的数据实际会以char型写入data中），然后关闭写入端，防止不同进程之间同时写入。<br>子进程中，调用read( )读取base之后（read函数读取过的数据会被自动从data中删除掉），对管道中剩下的数分别进行检验，筛掉合数，对剩下的不能整除base的数作为新的数组调用prime函数，递归直到只剩1个数，最终即得所有的质数。<br>本实验中，对于各进程需要注意wait(0)的位置，不然可能会导致某一进程提前结束进而导致shell的$符随机出现并因此无法通过测试。</p><h2 id="（3）实验代码-3">（3）实验代码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//primes fuction</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">;</span><span class="token comment">//埃氏筛法寻找质数</span><span class="token keyword">void</span> <span class="token function">primes</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fail to create pipe\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> base<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>    base <span class="token operator">=</span> <span class="token operator">*</span>array<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span><span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//每读出一段数据，被读出的数据会被从pipe中清除</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">%</span> base <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token operator">*</span>array <span class="token operator">=</span> temp<span class="token punctuation">;</span>                array <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">primes</span><span class="token punctuation">(</span>array <span class="token operator">-</span> ans<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> array<span class="token punctuation">[</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">primes</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1><strong>4.Find函数</strong></h1><h2 id="（1）实验目的-4">（1）实验目的</h2><p>在指定路径及其子文件夹内寻找指定名称的文件，格式为</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">find &lt;path&gt; &lt;filename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><h2 id="（2）实验步骤-4">（2）实验步骤</h2><p>题目中提示查看user/ls.c来了解怎样读取目录，发现ls.c实现的功能和题目要求的很相似，只缺少对文件名称进行比对后输出这一功能，故先将ls.c的代码copy至find.c中之后进行修改即可。</p><p>Ls.c的代码中，调用open( )获取相应的文件描述符并输入fd，调用fstat( )函数是st得到相应的文件属性，如果是文件，则输出，如果是文件夹，则在路径后加’/’和该文件夹下的文件名或者文件夹名，再调用该函数。</p><p>具体修改如下：在st.type是文件而不是文件夹的时候，调用strcmp函数对该文件的文件名与寻找的filename进行对比，如果一样则输出（此处需要先调用fmtname( )将路径名转化为文件名）。题目要求不输出“.”和“…”，故当de.name是“.”和“…”时，跳过</p><h2 id="（3）实验代码-4">（3）实验代码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//find fuction</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">fmtname</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">char</span> buf<span class="token punctuation">[</span>DIRSIZ <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token comment">// Find first character after last slash.</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">>=</span> path <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">;</span> p<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">// Return blank-padded name.</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">>=</span> DIRSIZ<span class="token punctuation">)</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token function">memmove</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// memset(buf + strlen(p), ' ', DIRSIZ - strlen(p));</span>    <span class="token keyword">return</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dirent</span> de<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot open %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot stat %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> T_FILE<span class="token operator">:</span>        <span class="token comment">// printf("%s %d %d %l\n", fmtname(path), st.type, st.ino, st.size);</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token function">fmtname</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> T_DIR<span class="token operator">:</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> DIRSIZ <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token keyword">sizeof</span> buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ls: path too long\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> buf <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>de<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>inum <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DIRSIZ<span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token punctuation">[</span>DIRSIZ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ls: cannot stat %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);</span>            <span class="token function">find</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error! You input too much argument or no argument.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">find</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h1><strong>5.xargs函数</strong></h1><h2 id="（1）实验目的-5">（1）实验目的</h2><p>在xv6中实现xargs指令，使前一条指令的输出由标准输入转化为命令行参数来作为后面指令的参数（之一）。此处要求实现的xargs指令前只有一个参数。</p><h2 id="（2）实验步骤-5">（2）实验步骤</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/xrags.jpg" alt="xrags" title="xrags指令样例"><br>以上图为例，如果一个指令以这样的形式输入命令行，则‘|’前的输出”hello too”会被存在0（缓冲区）中。</p><p>实现xargs时，只需要在其后指令（echo）的参数后缀上前面的输出，即从0中read出来并作为最后一个参数即可。然后调用fork ( )创建子进程并调用exec( )来执行“xargs”其后的指令即可。</p><h2 id="（3）实验代码-5">（3）实验代码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/param.h"</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error! You input too few arguments.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> MAXARG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error! You input too many arguments.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>command <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>argument<span class="token punctuation">[</span>MAXARG<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        argument<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    argument<span class="token punctuation">[</span>argc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\n'</span><span class="token punctuation">)</span>                 <span class="token keyword">break</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>        buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        argument<span class="token punctuation">[</span>argc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">exec</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> argument<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资本的限度の笔记</title>
    <link href="/2021/10/17/%E8%B5%84%E6%9C%AC%E7%9A%84%E9%99%90%E5%BA%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/17/%E8%B5%84%E6%9C%AC%E7%9A%84%E9%99%90%E5%BA%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="重印版序言">重印版序言</h2><p>此序言在最前，故从此开始。</p><p>出版于八十年代的原版很多预言已经应验，新自由主义席卷下的今天，资本主义及其阶级愈发以极小的人数比例占有极大比例的财富，并且在七十年代以来其统治愈发巩固。</p><p>何以无大规模的革命出现呢？一部分是群众之间日益碎片化，大家意见不再一致于社会主义革命；再者，新自由主义的规训使人们相信新自由主义可以带来其说的一般的福祉以及自己切身所处为自由，此种壁垒森严的思想铁壁使得各地人们趋向于在新自由主义规定好的议题下进行“抗争”（落入彀中矣）</p>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Marxism</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程</title>
    <link href="/2021/10/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/10/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>多线程编程</p><p>Linux提供的pthread库只允许向线程里传入一个参数，如果想传入多个参数，需要用结构体或者指针</p><h2 id="功能介绍">功能介绍</h2><p>该程序借助pthread线程库实现了多线程的快速排序，随机建立N个元素的int型数组，然后八线程地进行快速排序，然后对各线程的排序结果进行归并，并输出归并后的数组。<br>为检验实现的多线程快速排序的准确性，最后对原数组进行冒泡排序并输出排序后数组，两相对比可知。</p><h2 id="code">code</h2><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment">//多线程分开进行快排，最后对各线程快排结果进行归并</span><span class="token comment">//const int N = 1e3;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> NR_CPU <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">// int arr[] = &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token operator">*</span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">param_t</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>    <span class="token operator">*</span>y <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">quick_sort_recursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> start<span class="token punctuation">,</span> right <span class="token operator">=</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> mid <span class="token operator">&amp;&amp;</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">>=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        left<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">quick_sort_recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">quick_sort_recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">quick_sort_recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">runner</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">param_t</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">param_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>args<span class="token punctuation">;</span>    <span class="token function">quick_sort_recursive</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token operator">-></span>start<span class="token punctuation">,</span> p<span class="token operator">-></span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// for(i = p->start; i &lt;= p->end; ++i)&#123;</span>    <span class="token comment">//     printf("%d ", arr[i]);</span>    <span class="token comment">// &#125;</span>    <span class="token comment">// printf("\n");</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>n<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> n <span class="token operator">+</span> start<span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> n <span class="token operator">+</span> mid<span class="token punctuation">;</span>    <span class="token keyword">int</span> len1 <span class="token operator">=</span> mid <span class="token operator">-</span> start<span class="token punctuation">,</span> len2 <span class="token operator">=</span> end <span class="token operator">-</span> mid<span class="token punctuation">;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> len2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> p2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> p<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> p1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> p<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len1<span class="token punctuation">)</span> p<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> p1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> len2<span class="token punctuation">)</span> p<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> p2<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>n <span class="token operator">+</span> start<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// int N = (int) sizeof(arr) / sizeof(*arr);</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> step <span class="token operator">=</span> N <span class="token operator">/</span> NR_CPU<span class="token punctuation">;</span>    <span class="token class-name">param_t</span> params<span class="token punctuation">[</span>NR_CPU<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">pthread_t</span> pids<span class="token punctuation">[</span>NR_CPU<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// int i = 0;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NR_CPU<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        pids<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        params<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>n <span class="token operator">=</span> arr<span class="token punctuation">;</span>        params<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start <span class="token operator">=</span> i <span class="token operator">*</span> step<span class="token punctuation">;</span>        params<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end <span class="token operator">=</span> params<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start <span class="token operator">+</span> step<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    params<span class="token punctuation">[</span>NR_CPU <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>end <span class="token operator">=</span> N<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NR_CPU<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pids<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> runner<span class="token punctuation">,</span> <span class="token operator">&amp;</span>params<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NR_CPU<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">pthread_join</span><span class="token punctuation">(</span>pids<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>step <span class="token operator">&lt;</span> N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> step<span class="token punctuation">;</span>            <span class="token keyword">int</span> end <span class="token operator">=</span> mid <span class="token operator">+</span> step<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">></span> N<span class="token punctuation">)</span> mid <span class="token operator">=</span> N<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>end <span class="token operator">></span> N<span class="token punctuation">)</span> end <span class="token operator">=</span> N<span class="token punctuation">;</span>            <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            start <span class="token operator">=</span> end<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="讨论">讨论</h2><p>创建新线程时,利用pthread_create函数，该函数原型如下：<br><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);  </code><br>其中，参数thread用于缓存新线程的pid， 参数attr是新线程的线程属性，可以事先设置也可以缺省，第三个参数是函数指针，是新线程的运行的函数，本程序中是runner，参数arg是向新线程中传入的参数。<br>可以看到，通过pthread_create函数只能向新线程传入1个参数，这时一般通过结构体来达到传入多个参数的目的。<br>为防止各进程未执行完毕main函数就执行到输出数组，在print之前应用pthread_join函数来等待线程结束。在本程序中，线程在执行完runner函数之后自动终止。<br>多线程编程似乎一般用于各线程之间功能相似的程序，最后在主线程里需要进行汇总或者归并。</p>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU PA2 菜鸡记录</title>
    <link href="/2021/09/30/NEMU_PA2/"/>
    <url>/2021/09/30/NEMU_PA2/</url>
    
    <content type="html"><![CDATA[<h1><strong>闲话</strong></h1><p>NEMU是南大的一个课设，你天拿来当小学期任务，<s>端地一番折磨</s></p><p>本篇博客由PA2实验报告改编而来，后续可能会有必做题的过程<s>也可能没有</s></p><p><s>看阿瓜的懒惰程度了</s></p><h1><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>运行用户程序mov.c</td><td>已完成</td></tr><tr><td>必做任务2</td><td>实现更多指令</td><td>已完成</td></tr><tr><td>必做任务3</td><td>实现binary scaling</td><td>已完成</td></tr><tr><td>必做任务4</td><td>为表达式求值添加变量的支持</td><td>已完成</td></tr><tr><td>必做任务5</td><td>实现loader</td><td>已完成</td></tr><tr><td>选做任务1</td><td>打印栈帧链</td><td>已完成</td></tr><tr><td>选做任务2</td><td>改变程序的行为</td><td>未完成</td></tr></tbody></table><h1><strong>必做题</strong></h1><h1><strong>思考题</strong></h1><h2 id="思考题1：main函数返回到哪里">思考题1：main函数返回到哪里</h2><ul><li>在testcase里的测试文件中，程序从start函数里跳转到main函数，main函数执行完毕后再返回到start里。所以HIT GOOD TRAP 一般都在0x100014处</li></ul><h2 id="思考题2：比较FLOAT和float">思考题2：比较FLOAT和float</h2><ul><li>其区别首先在于FLOAT是定点数而float是浮点数，作为浮点数，float对于规格化的值与非规格化的值两种情况其阶码值和尾数的计算公式并不一样，这就使得其可以比较精确地表示0和非常接近于0的数以及非常大的数。而FLOAT由于定点化，在牺牲表数范围和精度的同时换取了速度。</li></ul><h2 id="思考题3：消失的符号">思考题3：消失的符号</h2><ul><li>符号表symtab中包含的符号有三类：1.非静态的c函数和全局变量;2.其他模块中定义的非静态c函数和全局变量;3.只在该模块中定义和引用的带static属性的C函数和全局变量。<br>对于非静态的局部变量则在栈中管理，并不被symtab包含</li></ul><h2 id="思考题4：堆和栈在哪里">思考题4：堆和栈在哪里</h2><ul><li>堆和栈的数据存取比较频繁，如果放入可执行文件可能导致运行速度下降。程序执行时，再从内部调用堆和栈。</li></ul><h2 id="思考题5：如何识别不同格式的可执行文件">思考题5：如何识别不同格式的可执行文件</h2><ul><li>ELF文件头有魔数，可以用做识别文件格式。</li></ul><h2 id="思考题6：冗余的属性">思考题6：冗余的属性</h2><ul><li>FileSiz表示程序头在文件中所占的大小，MemSiz表示程序头在内存中所占用的大小。</li></ul><h1>实验遇到的问题、思考、解决办法</h1><ul><li>对于必做任务三的FLOAT.c中的f2F函数实现曾出现过错误，然后修改过后仍hit bad trap，然后make clean之后再make run便可以运行。当时不知道make clean的原理，误以为f2F函数并没有错误，故又恢复原貌，导致提交的前一版stage2_finished不能通过integral.c测试。然后多次测试后发现FLOAT.c文件在修改后并不会重新编译，除非make clean。经助教齐学长讲解，明白了FLOAT.c生成的是动态链接库，不是可重定向目标文件，所以make clean之后才会重新编译。故最后修改正确之后补交了一版stage2_finished_new。</li></ul><h1>实验心得</h1><ul><li><p>ELF头文件前几个数是为魔数（magic number），用做识别文件类型之用。</p></li><li><p>HIT BAD TRAP一般可能是三种错误，</p><ul><li>1.exec.c文件里opcode表填写错误，比如某条指令形式应为rm2r误写成r2rm；</li><li>2,.指令的具体实现出现错误，例如jcc系列指令的条件判断写错或者call、ret、push、pop、leave等指令的ebp、esp寄存器相关内容出错;</li><li>3.FLOAT函数具体实现出错。</li></ul></li><li><p>需要写的程序不一定只在TODO标明的地方，其临近处或者其他地方也可能根据需要而添加或者修改代码</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU PA3 菜鸡记录</title>
    <link href="/2021/09/28/NEMU_PA3/"/>
    <url>/2021/09/28/NEMU_PA3/</url>
    
    <content type="html"><![CDATA[<h1><strong>闲话</strong></h1><p>NEMU是南大的一个课设，你天拿来当小学期任务，<s>端地一番折磨</s></p><p>本篇博客由PA3实验报告改编而来，后续可能会有必做题的过程<s>也可能没有</s></p><p><s>看阿瓜的懒惰程度了</s></p><h1><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>实现一级Cache</td><td>已完成</td></tr><tr><td>必做任务2</td><td>在NEMU中实现分段机制</td><td>已完成</td></tr><tr><td>必做任务3</td><td>在NEMU中实现分页机制</td><td>已完成</td></tr><tr><td>必做任务4</td><td>实现TLB</td><td>已完成</td></tr><tr><td>选做任务1</td><td>实现二级Cache</td><td>已完成</td></tr><tr><td>选做任务2</td><td>建议调试器</td><td>未完成</td></tr><tr><td>选做任务3</td><td>为用户进程创建video memory 映射</td><td>未完成</td></tr></tbody></table><h1><strong>思考题</strong></h1><h2 id="思考题1：GDT能有多大">思考题1：GDT能有多大</h2><ul><li>段选择符的结构中，INDEX有13位，故GDT最大能容纳2^13个段描述符</li></ul><h2 id="思考题2：为什么是线性地址">思考题2：为什么是线性地址</h2><ul><li>不可以。虚拟地址需要经GDT中的段表翻译才能得出地址，而如果GDTR中存放虚拟地址则找不到GDT在哪里了。</li></ul><h2 id="思考题3：如何提高寻找段描述符的效率">思考题3：如何提高寻找段描述符的效率</h2><ul><li>可以按照高速缓存的思想，建立类似cache 和 TLB 的结构来提高寻找效率。</li></ul><h2 id="思考题4：段式存储管理的缺点">思考题4：段式存储管理的缺点</h2><ul><li>分段管理要求分配一大段连续的存储空间，难以实现并且容易造成大量的外部碎片出现。</li></ul><h2 id="思考题5：页式存储管理的优点">思考题5：页式存储管理的优点</h2><ul><li>没有外部碎片，并且不再需要大段连续的存储空间，提高了内存的利用率。</li></ul><h2 id="思考题6：一些问题">思考题6：一些问题</h2><ol><li><ul><li>Q：为什么页表表项中的基地址信息只有20位而不是32位</li><li>A：分页基地址有20位是8086的传统<br>在8086的分段机制中，每个段的基地址由seg_reg（即段寄存器的值）&lt;&lt;4得到，而段寄存器是16位的，左移4位得到20位的基地址。</li></ul></li><li><ul><li>Q：表项和CR3中的基地址都是物理地址，这是必须的吗？能否采用虚拟地址或者线性地址？</li><li>A：是必须的，如果cr3中的基地址是虚拟地址，则无从寻找页表翻译成物理地址，进入鸡生蛋蛋生鸡的死循环。至于其他表项的虚拟地址与线性地址问题同理。</li></ul></li><li><ul><li>Q：为什么不采用一级页表？采用一级页表会有什么缺点？</li><li>A：多级页表可以有效地节约内存空间，如果仅采用一级页表，将可能导致较大的页表长期驻留在内存中。</li></ul></li></ol><h2 id="思考题7：空指针是“空”的吗">思考题7：空指针是“空”的吗</h2><ul><li>空指针只是未分配或者未指向内存任何位置的指针，并不是“NULL”的。</li></ul><h2 id="思考题8：在扁平模式下如何进行保护">思考题8：在扁平模式下如何进行保护</h2><ul><li>对于数据有不同的访问权限，未达到需要的权限时不能进行写操作。</li></ul><h2 id="思考题9：地址映射">思考题9：地址映射</h2><p><img src="https://raw.githubusercontent.com/zcsryu2/Blog_images/main/%E6%80%9D%E8%80%83%E9%A2%989.png" alt="思考题9" title="思考题9"></p><h2 id="思考题10：">思考题10：</h2><ul><li>pframe_addr是无符号类型，它的值永远大于等于0，所以for循环无法退出，出现错误。</li></ul><h2 id="思考题11：分页机制">思考题11：分页机制</h2><ol><li><ul><li>因为这里定义的ｘ生成的地址是虚拟地址，超过了物理地址的界限，报错0xc014a000 outside of the physical memory。<br>而ｋvm.c 中的虚拟地址都经过了 va_to_pa 的转换，在物理地址范围之内。</li></ul></li><li><ul><li>进行反汇编后，其地址如下：<br>c01003d6:e8 65 09 00 00       call   c0100d40<br>&lt;init_page&gt;<br>该call指令的opcode为e8，实现的是跳转到：该条指令的下一条指令的首地址+偏移量的位置。由于未进行寻址，故不需要进行虚实地址转化。</li></ul></li><li><ul><li>分页的环境下，在没有初始化页表时，0～128M的虚拟地址到物理地址的映射相当于一个简易的页表，使得高位的地址可以通过该虚拟地址（即经过va_to_pa）访问到物理地址，从而进行初始化页表的操作。</li></ul></li><li><ul><li>init_mm()函数执行退出时。该函数将nemu映射到了高位地址并且将之前的PDE全部置为无效，此时返回main.c时，栈中保存的返回地址需要经过虚实转换，可由于页面被置为了无效，所以报错。</li></ul></li><li><ul><li>查看汇编代码，直接调用此函数时，nemu运行在物理地址上，由于在init_mm中将之前的PDE都置为无效，所以在loader()函数寻址时页面无效，导致报错。</li></ul></li></ol><h1>实验遇到的问题、思考、解决办法</h1><ul><li>对GDT一直看不很明白，以为数组的元素大小也需要跟处理器位数一样，最大是32位，实际上GDT的元素就是64位的段描述符，不过是分成了两个32位的结构体</li><li>由于初始时对分段很不理解，然后对指导书内容进行了相应的整理，如下：<ul><li><p>由于内存的增长，单纯段寄存器无法满足寻址需要，需要采用分段机制。</p></li><li><p>80386作为32位处理器，故提供的指针都是32位的，而段寄存器只有16位，而段描述符有64位，用指针存储也无法做到。故采用GDT（Global Descriptor Table, 全局描述符表）来存储段描述符。</p></li><li><p>GDT是一个数组，数组元素是64位的段描述符（实际上是一个有两个32位member的结构体）而数组下标则由段寄存器的前13位得到（最后两位用来描述优先级，中间1位TI用来判断是GDT还是LDT）（GDT是全局描述符表，而LDT是每个进程的描述符表，由于分页机制的出现，LDT并不需要在NEMU中实现）</p></li><li><p>CPU还需要记录GDT的基地址，这通过设置一个GDTR的寄存器来实现，该寄存器有48位，前32位类似于指针存放GDT的首地址，后16位记录GDT的长度</p></li></ul></li></ul><h1>实验心得</h1><ul><li>指针最大位数受CPU位数影响，所以才需要GDT进行段描述符的存储和读取</li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU PA1 菜鸡记录</title>
    <link href="/2021/09/21/NEMU_PA1/"/>
    <url>/2021/09/21/NEMU_PA1/</url>
    
    <content type="html"><![CDATA[<h1><strong>闲话</strong></h1><p>NEMU是南大的一个课设，你天拿来当小学期任务，<s>端地一番折磨</s></p><p>本篇博客由PA1实验报告改编而来，后续可能会有必做题的过程<s>也可能没有</s></p><p><s>看阿瓜的懒惰程度了</s></p><h1><strong>实验进度表</strong></h1><table><thead><tr><th>任务序号</th><th>任务内容</th><th>完成情况</th></tr></thead><tbody><tr><td>必做任务1</td><td>实现正确的寄存器结构体</td><td>已完成</td></tr><tr><td>必做任务2</td><td>实现单步执行、打印寄存器、扫描内存</td><td>已完成</td></tr><tr><td>必做任务3</td><td>实现算术表达式的词法分析</td><td>已完成</td></tr><tr><td>必做任务4</td><td>实现算术表达式的递归求值</td><td>已完成</td></tr><tr><td>选做任务1</td><td>实现带有负数的算术表达式的求值</td><td>已完成</td></tr><tr><td>必做任务5</td><td>实现更复杂的表达式求值</td><td>已完成</td></tr><tr><td>选做任务2</td><td>实现指针解引用</td><td>已完成</td></tr><tr><td>必做任务6</td><td>实现监视点池的管理</td><td>已完成</td></tr><tr><td>必做任务7</td><td>实现监视点</td><td>已完成</td></tr></tbody></table><h1><strong>必做题</strong></h1><h1><strong>思考题</strong></h1><h2 id="思考题1-：opcode-table数组的类型">思考题1 ：opcode_table数组的类型</h2><ul><li>opcode_table为helper_fun类型的数组，而helper_fun类型为指向参数类型为swaddr_t且返回值类型为int的函数指针，故opcode_table为函数指针数组。</li></ul><h2 id="思考题2">思考题2</h2><h3 id="（1）要执行多久">（1）要执行多久</h3><ul><li>cpu_exec函数的参数是uint32_t，即无符号整型，而传入的-1因会导致溢出而成为最大的无符号整型数，保证能够执行完输入的所有指令。</li></ul><h3 id="（2）为什么要使用static">（2）为什么要使用static</h3><ul><li><p>Q：框架代码中定义 wp_pool 等变量的时候使用了关键字 static，static 在此处的含义是什么? 为什么要在此处使用它?</p></li><li><p>A： static表示wp_pool为静态全局变量，此处使用static是为了避免wp_pool在程序运行中被误修改。</p></li></ul><h2 id="思考题3：读手册的方法">思考题3：读手册的方法</h2><ol><li><ul><li>Q： EFLAGS 寄存器中的 CF 位是什么意思</li><li>A: 在目录中检索register和flag发现2.3.4.1节和附录c有提及相关内容，查阅得：CF为进位标志，如果运算导致最高位产生进位或者借位则为1.否则为0。</li></ul></li><li><ul><li>Q: ModR/M 字节是什么</li><li>A: 检索目录得ModR/M相关内容在17.2.1节，查阅可知ModR/M字节包括mod、reg、r/m三方面内容,分别表示索引类型或者寄存器编号、寻址模式编码等信息。</li></ul></li><li><ul><li>Q: mov 指令的具体格式是怎么样的</li><li>A: 检索目录在12.2.2.11节内找到mov指令相关内容，查阅可知格式为DEST←SRC</li></ul></li><li><ul><li>shell命令:<br>find . -name “*[.h|.cpp]” | xargs wc -l<br>使用上述命令，得代码共129281行</li></ul></li><li><ul><li><p>Make文件：</p><p>-Wall 使GCC产生尽可能多的警告信息，取消编译操作，打印出编译时所有错误或警告信息。</p><p>-Werror 要求GCC将所有的警告当成错误进行处理，从而终止编译操作。</p><p>使用-Wall和-Werror就是为了找出所有存在的或者潜在的错误，优化程序。</p></li></ul></li></ol><h1>实验遇到的问题、思考、解决办法</h1><ul><li><p>在刚开始实验的时候，遇到“Makefile : “run”…”这种错误会不知所措，Prof Wei指点我要慢慢debug，通过Log、Assert等函数以及GDB等工具，最终解决了bug。<s>（GDB过于生疏，PA1完全靠肉眼debug）</s></p></li><li><p>某次在虚仿平台关机导致git文件损坏，csdn、stackoverflow搜索到的办法都未能解决问题，最终在Wei老师的帮助下通过删除然后重新绑定远程仓库解决了问题。</p></li><li><p>打印寄存器时起初不知道如何依次打印，后来发现reg.h文件下有定义好的regsl数组和reg_l函数可以利用。</p></li></ul><h1>实验心得</h1><ul><li><p>要细读实验指导书，里面内容很详细，开始时候因为只看PPT导致忽略掉了很多细节内容。</p></li><li><p>调试程序时要善于使用gdb等工具，小型的bug可以使用Log、Assert等函数两面夹击来判断bug出现在哪里，总之对bug不要失措.</p></li><li><p>对于某任务中所用到的文件中的代码要通读一下，不求全看懂，多少知道相关函数、数组是做什么的，比如reg.h文件下的regsl数组和reg_l函数，</p></li><li><p>在.c文件中声明函数后要在.h文件中定义</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NEMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/21/hello-world/"/>
    <url>/2021/09/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>The First One</title>
    <link href="/2021/07/03/The-First-One/"/>
    <url>/2021/07/03/The-First-One/</url>
    
    <content type="html"><![CDATA[<p>这是王珣的第一篇博客，自然要题写几个大字</p><p>hello, world!</p><p><img src="https://raw.githubusercontent.com/zcsryu2/BlogImages/main/hello_world_movie.jpg" alt="这是图片" title="hello world"><br>（划掉）</p><p><img src="https://raw.githubusercontent.com/zcsryu2/BlogImages/main/hello_world.jpg" alt="这是图片" title="hello, world"></p><p>以上</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闲话</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
